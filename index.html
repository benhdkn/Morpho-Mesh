<!DOCTYPE html>

<html>
	<head>
		<title>Morpho-Mesh</title>
		<meta http-equiv="content-type" content="text/html; charset=ISO-8859-1">
		<meta name="viewport" content="width=device-width, height=device-height, initial-scale=1">
		<style type="text/css">
			html, body { 
                margin: 0 auto; 
                padding: 0; border: none; 
            }

            /* #threejs-canvas {
                width: 100%;
                height: 100%;

            } */

			#mode-list {
				position: absolute;
				top: 2%;
				left: 50%;
				height: 20px;
				transform: translateX(-50%);
				font-family: consolas, sans-serif;
				font-size: 10px;
				color: white;
				z-index: 10;
			}

			#black-band-top, #black-band-bottom {
				position: absolute;
				width: 100%;
				height: 200px;
				z-index: 5;
				background-color: black;
			}

			#black-band-bottom {
				bottom: 0;
			}
		</style>

		<script src="js/Three.min.js"></script>
		<script src="js/Detector.js"></script>
		<script src="js/ImprovedNoise.js"></script>
		<script src="js/OrbitControls.js"></script>
	</head>
	<body>

		<div id="black-band-top"></div>
		<div id="black-band-bottom"></div>

		<div id="threejs-canvas">

		<script>
			var scene;
			var camera;
			var clock;
			var controls;

			var geometry;

			var timer = 0;
			var pointsYInitValues = [];
			var pointsYRandomDir = [];
			
			var _hasChangedDirection = false;
			var hasChangedDirection = false;

			initializeScene();
			animateScene();

			function initializeScene(){
				// Renderer
				if (Detector.webgl) {
					renderer = new THREE.WebGLRenderer({ antialiasing:true });
				} 
				else {
					renderer = new THREE.CanvasRenderer();
				}
                renderer.setSize(window.innerWidth, window.innerHeight);
				renderer.setPixelRatio(2);
                document.body.appendChild(renderer.domElement);
				
				// Scene
				scene = new THREE.Scene();

				// Timer
				clock = new THREE.Clock();

				// Lighting
				var light = new THREE.PointLight(0xffffff, 1, 0);
				light.position.set(0, 200, 0);
				scene.add(light);

				// Camera
				camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 10000);
				camera.position.set(0, 1800, 0);
				scene.add(camera);

				// Controls
				controls = new THREE.OrbitControls(camera);
				// controls.autoRotate = true;
				controls.autoRotateSpeed = 0.5;

				// Meshes
				var noiseData = generateNoise(1024, 1024);
				var quality = 8;
				var step = 1024 / quality;

				geometry = new THREE.PlaneGeometry(600, 600, quality - 1, quality - 1);
				// Rotate the geometry
				geometry.applyMatrix(new THREE.Matrix4().makeRotationX(- Math.PI / 2));
				// Generate noise
				for (var i = 0, l = geometry.vertices.length; i < l; i ++) {
					var x = i % quality;
					var y = Math.floor(i / quality);
					var noiseY = noiseData[(x * step) + (y * step) * 1024] * 2 - 128;
					geometry.vertices[i].y = noiseY;
					pointsYInitValues.push(noiseY);
					var dir = Math.random() < 0.5 ? -1 : 1;
					pointsYRandomDir.push(dir);
				}

				var baseLitMaterial = new THREE.MeshPhongMaterial({
					color: 0x191919,
					emissive: 0x0c2426,
					specular: 0xb62d2d,
    				shininess: 10,
					shading: THREE.FlatShading,
					side: THREE.DoubleSide,
					depthTest: false,
				});
				
				var baseMesh = new THREE.Mesh(geometry, baseLitMaterial);
				baseMesh.position.set(0, 0, 0);
				baseMesh.rotation.y = Math.PI / 4;
				scene.add(baseMesh);

				var lineMaterial = new THREE.LineBasicMaterial({
					color: 0x717171
				});

				var lineLeftGeometry = new THREE.Geometry();
				lineLeftGeometry.vertices.push(new THREE.Vector3(-10000, 0, 0));
				lineLeftGeometry.vertices.push(new THREE.Vector3(-450, 0, 0));
				var lineLeft = new THREE.Line(lineLeftGeometry, lineMaterial);
				scene.add(lineLeft);

				var lineRightGeometry = new THREE.Geometry();
				lineRightGeometry.vertices.push(new THREE.Vector3(10000, 0, 0));
				lineRightGeometry.vertices.push(new THREE.Vector3(450, 0, 0));
				var lineRight = new THREE.Line(lineRightGeometry, lineMaterial);
				scene.add(lineRight);
				
				// Set the orbit control to rotate around the mesh center
				var geomCenter = THREE.GeometryUtils.center(geometry);
				controls.center = geomCenter;
				
				// Event listeners
				window.addEventListener('resize', onWindowResize, false);
                window.addEventListener('keydown', onKeyDown, false);

			}

			function generateNoise(width, height) {
				var data = new Uint8Array(width * height);
				var perlin = new ImprovedNoise();
				var size = width * height;
				var quality = 1;
				var z = Math.random() * 100;

				for (var j = 0; j < 4; j ++) {
					quality *= 4;
					for (var i = 0; i < size; i ++) {
						var x = i % width, y = ~~ (i / width);
						data[i] += Math.abs(perlin.noise(x / quality, y / quality, z) * 0.5) * quality + 10;
					}
				}
				return data;
			}

			var temp = 0;

			function animateScene() {
				requestAnimationFrame(animateScene);
				renderScene();

				timer += clock.getDelta();

				// Doesn't work out of the function
				geometry.verticesNeedUpdate = true;

				// Sin move the points
				for (i = 0; i < geometry.vertices.length; i++) {
					var dir = pointsYRandomDir[i];
					var vertice = geometry.vertices[i];
					// var initYPos = pointsYInitValues[i];
					var newYPos = (Math.sin(timer) * 10.0 * dir);
					vertice.y = newYPos;
				}

				controls.update();
			}

			function renderScene() {
				renderer.setClearColor(0x1e1e1e, 1);
				renderer.render(scene, camera);
			}

			function onWindowResize(){
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();

                renderer.setSize(window.innerWidth, window.innerHeight);
            }

			function onKeyDown() {
                switch (event.keyCode) {
                    case 32: // Space

                        break;
                }
            }
		</script>
	</body>
</html>
